//[Burst] [Simple Burst]B Blur,3
//Don't delete the previous line or this one
Shader "Hidden/VFX/Burst/Simple Burst/B/Blur"
{
	SubShader
	{
		Tags { "Queue"="Transparent+0" "IgnoreProjector"="True" "RenderType"="Transparent" }
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		// Strips tangent computation
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		Blend SrcAlpha OneMinusSrcAlpha
		ZTest LEqual
		ZWrite Off
		Cull Back
		

		
		HLSLINCLUDE
		#pragma only_renderers d3d11 glcore gles3 metal vulkan xboxone xboxone xboxseries playstation ps5 switch webgpu
		
		#define NB_THREADS_PER_GROUP 64
		#define HAS_VFX_ATTRIBUTES 1
		#define VFX_PASSDEPTH_ACTUAL (0)
		#define VFX_PASSDEPTH_MOTION_VECTOR (1)
		#define VFX_PASSDEPTH_SELECTION (2)
		#define VFX_PASSDEPTH_PICKING (3)
		#define VFX_PASSDEPTH_SHADOW (4)
		#define VFX_USE_POSITION_CURRENT 1
		#define VFX_USE_ANGLEX_CURRENT 1
		#define VFX_USE_ANGLEY_CURRENT 1
		#define VFX_USE_ANGLEZ_CURRENT 1
		#define VFX_USE_COLOR_CURRENT 1
		#define VFX_USE_ALPHA_CURRENT 1
		#define VFX_USE_ALIVE_CURRENT 1
		#define VFX_USE_AXISX_CURRENT 1
		#define VFX_USE_AXISY_CURRENT 1
		#define VFX_USE_AXISZ_CURRENT 1
		#define VFX_USE_PIVOTX_CURRENT 1
		#define VFX_USE_PIVOTY_CURRENT 1
		#define VFX_USE_PIVOTZ_CURRENT 1
		#define VFX_USE_SIZE_CURRENT 1
		#define VFX_USE_SCALEX_CURRENT 1
		#define VFX_USE_SCALEY_CURRENT 1
		#define VFX_USE_SCALEZ_CURRENT 1
		#define RAW_CAPACITY 32u
		#define VFX_COLORMAPPING_DEFAULT 1
		#define IS_TRANSPARENT_PARTICLE 1
		#define VFX_BLENDMODE_ALPHA 1
		#define VFX_HAS_INDIRECT_DRAW 1
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		#define VFX_WORLD_SPACE 1
		#include_with_pragmas "Packages/com.unity.render-pipelines.universal/Runtime/VFXGraph/Shaders/VFXDefines.hlsl"
		#define VFX_USE_INSTANCING 1
		#define VFX_INSTANCING_FIXED_SIZE 32
		#pragma multi_compile_instancing
		

		
		ByteAddressBuffer graphValuesBuffer;
		
		
		
		Texture2D mainTexture;
		SamplerState samplermainTexture;
		float4 mainTexture_TexelSize;
		
		struct VFXAttributes
		{
		    float3 position;
		    float angleX;
		    float angleY;
		    float angleZ;
		    float3 color;
		    float alpha;
		    bool alive;
		    float3 axisX;
		    float3 axisY;
		    float3 axisZ;
		    float pivotX;
		    float pivotY;
		    float pivotZ;
		    float size;
		    float scaleX;
		    float scaleY;
		    float scaleZ;
		};
		
		struct VFXSourceAttributes
		{
		};
		
		

		
		#define VFX_NEEDS_COLOR_INTERPOLATOR (VFX_USE_COLOR_CURRENT || VFX_USE_ALPHA_CURRENT)
		#if HAS_STRIPS
		#define VFX_OPTIONAL_INTERPOLATION
		#else
		#define VFX_OPTIONAL_INTERPOLATION nointerpolation
		#endif
		
		#if VFX_USE_INSTANCING
		#define VFX_VERTEX_OUTPUT_INSTANCE_INDEX nointerpolation uint2 instanceIndices : INDEX0; //instanceCurrentIndex, instanceActiveIndex
		#define VFX_VARYINGS_INSTANCE_CURRENT_INDEX instanceIndices.x
		#define VFX_VARYINGS_INSTANCE_ACTIVE_INDEX instanceIndices.y
		#ifdef UNITY_INSTANCING_ENABLED
		    #define VFX_FRAG_SETUP_INSTANCE_ID(i) unity_InstanceID = i.VFX_VARYINGS_INSTANCE_CURRENT_INDEX
		#else
		    #define VFX_FRAG_SETUP_INSTANCE_ID(i)
		#endif
		#else
		#define VFX_VERTEX_OUTPUT_INSTANCE_INDEX
		#endif
		
		ByteAddressBuffer attributeBuffer;
		
		#if VFX_HAS_INDIRECT_DRAW
		StructuredBuffer<uint> indirectBuffer;
		#endif
		
		#if USE_DEAD_LIST_COUNT
		StructuredBuffer<uint> deadList;
		#endif
		
		#if HAS_STRIPS_DATA
		StructuredBuffer<uint> stripDataBuffer;
		#endif
		
		#if VFX_FEATURE_MOTION_VECTORS
		ByteAddressBuffer elementToVFXBufferPrevious;
		
		#if defined(VFX_FEATURE_MOTION_VECTORS_VERTS)
		
		#define VFX_DECLARE_MOTION_VECTORS_STORAGE(coordA, coordB)\
		noperspective float4 cPosPreviousAndNonJiterred : TEXCOORD##coordA;
		
		#define VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS cPosPreviousAndNonJiterred.xy
		#define VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER cPosPreviousAndNonJiterred.zw
		
		#else
		
		#define VFX_DECLARE_MOTION_VECTORS_STORAGE(coordA, coordB)\
		float4 cPosPrevious : TEXCOORD##coordA;\
		float4 cPosNonJiterred : TEXCOORD##coordB;
		
		#define VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS cPosPrevious
		#define VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER cPosNonJiterred
		
		#endif
		#endif
		
		CBUFFER_START(outputParamsConst)
		    
		    		float4 instancingConstants;
		    		uint2 instancingBufferOffsets;
		    		
		    float3 cameraXRSettings;
		CBUFFER_END
		
		UNITY_INSTANCING_BUFFER_START(PerInstance)
		    UNITY_DEFINE_INSTANCED_PROP(float, _InstanceIndex)
		    UNITY_DEFINE_INSTANCED_PROP(float, _InstanceActiveIndex)
		UNITY_INSTANCING_BUFFER_END(PerInstance)
		
		// Helper macros to always use a valid instanceID
		#if defined(UNITY_STEREO_INSTANCING_ENABLED)
			#define VFX_DECLARE_INSTANCE_ID     UNITY_VERTEX_INPUT_INSTANCE_ID
			#define VFX_GET_INSTANCE_ID(i)      unity_InstanceID
		#else
			#define VFX_DECLARE_INSTANCE_ID     uint instanceID : SV_InstanceID;
			#define VFX_GET_INSTANCE_ID(i)      i.instanceID
		#endif
		
		ENDHLSL
		

		Pass
		{
		    Name "SceneSelectionPass"
			Tags { "LightMode"="SceneSelectionPass" }
		
			ZWrite On
			Blend Off
		
			HLSLPROGRAM
			#define VFX_PASSDEPTH VFX_PASSDEPTH_SELECTION
			#pragma target 4.5
			
			#if SHADERGRAPH_NEEDS_NORMAL_DEPTHONLY || defined(WRITE_NORMAL_BUFFER) || FORCE_NORMAL_OUTPUT_UNLIT_VERTEX_SHADER
			#define NEEDS_NORMAL 1
			#endif
			
			#if SHADERGRAPH_NEEDS_TANGENT_DEPTHONLY
			#define NEEDS_TANGENT 1
			#endif
			
			struct ps_input
			{
				float4 pos : SV_POSITION;
				#if USE_FLIPBOOK_INTERPOLATION
				float4 uv : TEXCOORD0;
				#else
				#if USE_FLIPBOOK_ARRAY_LAYOUT
				float3 uv : TEXCOORD0;
				#else
				float2 uv : TEXCOORD0;
				#endif
				#endif
			    #if VFX_SHADERGRAPH_HAS_UV1
			    float4 uv1 : TEXCOORD1;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV2
			    float4 uv2 : TEXCOORD2;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV3
			    float4 uv3 : TEXCOORD3;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_COLOR
			    float4 vertexColor : COLOR;
			    #endif
				#if USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION || VFX_USE_ALPHA_CURRENT
				// x: alpha threshold
				// y: frame blending factor
				// z: alpha
				nointerpolation float3 builtInInterpolants : TEXCOORD4;
				#endif
			
				#if USE_FLIPBOOK_MOTIONVECTORS
				// x: motion vectors scale X
				// y: motion vectors scale Y
				nointerpolation float2 builtInInterpolants2 : TEXCOORD5;
				#endif
			
			    #if VFX_NEEDS_POSWS_INTERPOLATOR
				float3 posWS : TEXCOORD6;
			    #endif
			
				#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
				VFX_DECLARE_MOTION_VECTORS_STORAGE(7,8)
				#endif
			    
			
			    #if NEEDS_NORMAL
			    float3 normal : TEXCOORD9;
			    #endif
			
			    #if NEEDS_TANGENT
			    float4 tangent : TEXCOORD10;
			    #endif
			
				UNITY_VERTEX_OUTPUT_STEREO
			
			    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
			};
			
			#define VFX_VARYING_PS_INPUTS ps_input
			#define VFX_VARYING_POSCS pos
			#define VFX_VARYING_ALPHA builtInInterpolants.z
			#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.x
			#define VFX_VARYING_FRAMEBLEND builtInInterpolants.y
			#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
			#define VFX_VARYING_UV uv
			
			#if VFX_NEEDS_POSWS_INTERPOLATOR
			#define VFX_VARYING_POSWS posWS
			#endif
			
			#if NEEDS_NORMAL
			#define VFX_VARYING_NORMAL normal
			#endif
			
			#if NEEDS_TANGENT
			#define VFX_VARYING_TANGENT tangent
			#endif
			
			#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
			#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
			#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
			#endif
			
			#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
			#define SHADERPASS SHADERPASS_MOTION_VECTORS
			#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL || VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
			
					#if defined(WRITE_NORMAL_BUFFER)
					#define SHADERPASS SHADERPASS_DEPTHNORMALSONLY
					#else
					#define SHADERPASS SHADERPASS_DEPTHONLY
					#endif
					
			#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
			#define SHADERPASS SHADERPASS_SHADOWS
			#endif
			
			#if !(defined(VFX_VARYING_PS_INPUTS) && defined(VFX_VARYING_POSCS))
			#error VFX_VARYING_PS_INPUTS, VFX_VARYING_POSCS and VFX_VARYING_UV must be defined.
			#endif
			
			#include "Packages/com.unity.render-pipelines.universal/Runtime/VFXGraph/Shaders/VFXCommon.hlsl"
			#include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.hlsl"
			#include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommonOutput.hlsl"
			

			void SetAttribute_3278B22F(inout float size, float _Size) /*channels:XYZ */
			{
			    size = _Size;
			}
			

			
			struct vs_input
			{
				float3 pos : POSITION;
				float2 uv : TEXCOORD0;
			    #if VFX_SHADERGRAPH_HAS_UV1
			    float4 uv1 : TEXCOORD1;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV2
			    float4 uv2 : TEXCOORD2;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV3
			    float4 uv3 : TEXCOORD3;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_COLOR
			    float4 vertexColor : COLOR;
			    #endif
				float3 normal : NORMAL;
				#if defined(VFX_VARYING_TANGENT) || SHADERGRAPH_HAS_NORMAL
				float4 tangent : TANGENT;
				#endif
				VFX_DECLARE_INSTANCE_ID
			};
			
			#pragma vertex vert
			VFX_VARYING_PS_INPUTS vert(vs_input i)
			{
			    VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;
			
				UNITY_SETUP_INSTANCE_ID(i);
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
			
				uint index = VFX_GET_INSTANCE_ID(i);
			
				
						uint instanceIndex, instanceActiveIndex, instanceCurrentIndex;
						index = VFXInitInstancing(index, instanceIndex, instanceActiveIndex, instanceCurrentIndex);
						
				
			
				struct ContextData
				{
				    uint maxParticleCount;
				    uint systemSeed;
				    uint initSpawnIndex;
				};
				ContextData contextData;
				uint4 rawContextData = graphValuesBuffer.Load4(instanceActiveIndex * 160);
				contextData.maxParticleCount = rawContextData.x;
				contextData.systemSeed = rawContextData.y;
				contextData.initSpawnIndex = rawContextData.z;
				

				uint systemSeed = contextData.systemSeed;
				uint nbMax = contextData.maxParticleCount;
			
				
						#if HAS_STRIPS && !VFX_HAS_INDIRECT_DRAW
							// We render one particle less for each strip in this case
							nbMax -= STRIP_COUNT;
						#endif
						
						uint deadCount = 0;
						#if USE_DEAD_LIST_COUNT
						deadCount = deadList[instanceIndex];
						#endif
						#if VFX_USE_INSTANCING
						if (index >= nbMax - deadCount)
						#else
						if (index >= asuint(nbMax) - deadCount)
						#endif
						{
							CULL_VERTEX(o);
						}
						
						VFXAttributes attributes = (VFXAttributes)0;
						VFXSourceAttributes sourceAttributes = (VFXSourceAttributes)0;
						
						#if VFX_HAS_INDIRECT_DRAW
						if (index >= indirectBuffer[instanceActiveIndex])
						{
							CULL_VERTEX(o);
						}
						index = indirectBuffer[VFXGetIndirectBufferIndex(index, instanceActiveIndex)];
						#endif
						
						#if HAS_STRIPS_DATA
						StripData stripData;
						uint relativeIndexInStrip = 0;
						if (!FindIndexInStrip(index, id, instanceIndex, relativeIndexInStrip, stripData))
						{
							CULL_VERTEX(o);
						}
						#endif
						
						#if VFX_HAS_INDIRECT_DRAW
						attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x140) + (index * 0x4 + 0x20)) << 2));
						attributes.angleX = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA0)) << 2));
						attributes.angleY = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA1)) << 2));
						attributes.angleZ = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA2)) << 2));
						attributes.color = float3(1, 1, 1);
						attributes.alpha = (float)1;
						attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x1 + 0x100)) << 2));
						attributes.axisX = float3(1, 0, 0);
						attributes.axisY = float3(0, 1, 0);
						attributes.axisZ = float3(0, 0, 1);
						attributes.pivotX = (float)0;
						attributes.pivotY = (float)0;
						attributes.pivotZ = (float)0;
						attributes.size = (float)0.100000001;
						attributes.scaleX = (float)1;
						attributes.scaleY = (float)1;
						attributes.scaleZ = (float)1;
						
				
						#else
						attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x1 + 0x100)) << 2));
						
				
						#if !HAS_STRIPS
						if (!attributes.alive)
						{
							CULL_VERTEX(o);
						}
						#endif
						
						attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x140) + (index * 0x4 + 0x20)) << 2));
						attributes.angleX = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA0)) << 2));
						attributes.angleY = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA1)) << 2));
						attributes.angleZ = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA2)) << 2));
						attributes.color = float3(1, 1, 1);
						attributes.alpha = (float)1;
						attributes.axisX = float3(1, 0, 0);
						attributes.axisY = float3(0, 1, 0);
						attributes.axisZ = float3(0, 0, 1);
						attributes.pivotX = (float)0;
						attributes.pivotY = (float)0;
						attributes.pivotZ = (float)0;
						attributes.size = (float)0.100000001;
						attributes.scaleX = (float)1;
						attributes.scaleY = (float)1;
						attributes.scaleZ = (float)1;
						
				
						#endif
						
						// Initialize built-in needed attributes
						#if HAS_STRIPS_DATA
						InitStripAttributes(index, attributes, stripData);
						#endif
						
				{
				    SetAttribute_3278B22F( /*inout */attributes.size, (float)0.100000001);
				}
				

			
				if (!attributes.alive)
					return o;
			
			    #ifdef VFX_VARYING_UV
			    o.VFX_VARYING_UV.xy = i.uv;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV1
			    o.uv1 = i.uv1;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV2
			    o.uv2 = i.uv2;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV3
			    o.uv3 = i.uv3;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_COLOR
			    o.vertexColor = i.vertexColor;
			    #endif
			
				
						float3 size3 = float3(attributes.size,attributes.size,attributes.size);
						#if VFX_USE_SCALEX_CURRENT
						size3.x *= attributes.scaleX;
						#endif
						#if VFX_USE_SCALEY_CURRENT
						size3.y *= attributes.scaleY;
						#endif
						#if VFX_USE_SCALEZ_CURRENT
						size3.z *= attributes.scaleZ;
						#endif
						
			
				float3 inputVertexPosition = i.pos;
				float4x4 elementToVFX = GetElementToVFXMatrix(
					attributes.axisX,
					attributes.axisY,
					attributes.axisZ,
					float3(attributes.angleX,attributes.angleY,attributes.angleZ),
					float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
					size3,
					attributes.position);
			
				float3 vPos = mul(elementToVFX,float4(inputVertexPosition,1.0f)).xyz;
				float4 csPos = TransformPositionVFXToClip(vPos);
				o.VFX_VARYING_POSCS = csPos;
			
				// TODO This is needed only if in local space (to handle non uniform scale) or if scale attributes are stored/written (no way to know atm)
				float3x3 elementToVFX_N = GetElementToVFXMatrixNormal(
					attributes.axisX,
					attributes.axisY,
					attributes.axisZ,
					float3(attributes.angleX,attributes.angleY,attributes.angleZ),
					size3);
			
				float3 normalWS = normalize(TransformNormalVFXToWorld(mul(elementToVFX_N, i.normal)));
				#ifdef VFX_VARYING_NORMAL
				float normalFlip = (size3.x * size3.y * size3.z) < 0 ? -1 : 1;
				o.VFX_VARYING_NORMAL = normalFlip * normalWS;
				#endif
				#ifdef VFX_VARYING_TANGENT
				o.VFX_VARYING_TANGENT = float4(normalize(TransformDirectionVFXToWorld(mul((float3x3)elementToVFX,i.tangent.xyz))),i.tangent.w);
				#endif
			
				
						#if VFX_FEATURE_MOTION_VECTORS && defined(VFX_VARYING_VELOCITY_CPOS_PREVIOUS) && defined(VFX_VARYING_VELOCITY_CPOS)
						
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = (float2)0.0f;
						#else
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = float4(0.0f, 0.0f, 0.0f, 1.0f);
						#endif
						
						
						uint elementToVFXBaseIndex;
						if (TryGetElementToVFXBaseIndex(index, instanceIndex, elementToVFXBaseIndex, currentFrameIndex))
						{
						float4 cPos = TransformPositionVFXToNonJitteredClip(vPos);
						
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = VFXGetPreviousClipPosition(elementToVFXBaseIndex, id).xy;
							o.VFX_VARYING_VELOCITY_CPOS = cPos.xy / cPos.w;
						#else
							float4x4 previousElementToVFX = VFXGetPreviousElementToVFX(elementToVFXBaseIndex);
							float3 oldvPos = mul(previousElementToVFX, float4(inputVertexPosition, 1.0f)).xyz;
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = TransformPositionVFXToPreviousClip(oldvPos);
							o.VFX_VARYING_VELOCITY_CPOS = cPos;
						#endif
						
						}
						#endif
						
			
				
						#if VFX_USE_COLOR_CURRENT && defined(VFX_VARYING_COLOR)
						o.VFX_VARYING_COLOR = attributes.color;
						#endif
						#if VFX_USE_ALPHA_CURRENT && defined(VFX_VARYING_ALPHA)
						o.VFX_VARYING_ALPHA = attributes.alpha;
						#endif
						
						#ifdef VFX_VARYING_EXPOSUREWEIGHT
						
						o.VFX_VARYING_EXPOSUREWEIGHT = exposureWeight;
						#endif
						
						#if USE_SOFT_PARTICLE && defined(VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE)
						
						o.VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE = invSoftParticlesFadeDistance;
						#endif
						
						#if (USE_ALPHA_TEST || VFX_FEATURE_MOTION_VECTORS_FORWARD) && (!VFX_SHADERGRAPH || !HAS_SHADERGRAPH_PARAM_ALPHACLIPTHRESHOLD) && defined(VFX_VARYING_ALPHATHRESHOLD)
						
						o.VFX_VARYING_ALPHATHRESHOLD = alphaThreshold;
						#endif
						
						#if USE_UV_SCALE_BIAS
						
						
						#if defined (VFX_VARYING_UV)
						o.VFX_VARYING_UV.xy = o.VFX_VARYING_UV.xy * uvScale + uvBias;
						#endif
						#endif
						
						#ifdef VFX_VARYING_ANGLEFADE
						
						o.VFX_VARYING_ANGLEFADE = angleFade;
						#endif
						
						#ifdef VFX_VARYING_FADEFACTOR
						
						o.VFX_VARYING_FADEFACTOR = fadeFactor;
						#endif
						
						#ifdef VFX_VARYING_DECALLAYER
						
						o.VFX_VARYING_DECALLAYER = decalLayerMask;
						#endif
						
						#if defined(VFX_VARYING_POSWS)
						o.VFX_VARYING_POSWS = TransformPositionVFXToWorld(vPos);
						#endif
						
						#if VFX_USE_INSTANCING
						    #ifdef UNITY_INSTANCING_ENABLED
						    o.VFX_VARYINGS_INSTANCE_CURRENT_INDEX = unity_InstanceID;
						    #endif
						o.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX = instanceActiveIndex;
						#endif
						
			
				
						#if USE_FLIPBOOK && defined(VFX_VARYING_UV)
							#if USE_FLIPBOOK_ARRAY_LAYOUT
								
								#if USE_FLIPBOOK_INTERPOLATION
									VFXUVData uvData = GetUVData(flipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex, attributes.texIndexBlend);
								#else
									VFXUVData uvData = GetUVData(flipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex);
								#endif
								o.VFX_VARYING_UV.xyz = uvData.uvs.xyz;
								#if USE_FLIPBOOK_INTERPOLATION && defined(VFX_VARYING_UV) && defined (VFX_VARYING_FRAMEBLEND)
									o.VFX_VARYING_UV.w = uvData.uvs.w;
									o.VFX_VARYING_FRAMEBLEND = uvData.blend;
									#if USE_FLIPBOOK_MOTIONVECTORS && defined(VFX_VARYING_MOTIONVECTORSCALE)
										
										o.VFX_VARYING_MOTIONVECTORSCALE = motionVectorScale;
									#endif
								#endif
							#else
								
								
								#if USE_FLIPBOOK_INTERPOLATION
									VFXUVData uvData = GetUVData(flipBookSize, invFlipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex, attributes.texIndexBlend);
								#else
									VFXUVData uvData = GetUVData(flipBookSize, invFlipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex);
								#endif
								o.VFX_VARYING_UV.xy = uvData.uvs.xy;
								#if USE_FLIPBOOK_INTERPOLATION && defined(VFX_VARYING_UV) && defined (VFX_VARYING_FRAMEBLEND)
									o.VFX_VARYING_UV.zw = uvData.uvs.zw;
									o.VFX_VARYING_FRAMEBLEND = uvData.blend;
									#if USE_FLIPBOOK_MOTIONVECTORS && defined(VFX_VARYING_MOTIONVECTORSCALE)
										
										o.VFX_VARYING_MOTIONVECTORSCALE = motionVectorScale * invFlipBookSize;
									#endif
								#endif
							#endif
						#endif
						
			
				
			
			    
			
				return o;
			}
			
			
			
			
			
			
			#define VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH 1
			
					
					#ifndef VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH
					#define VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH 0
					#endif
					
					#ifdef VFX_SHADERGRAPH
						#if (SHADERPASS == SHADERPASS_DEPTHNORMALSONLY)
						
						#else
						
						#endif
					#endif
					
					#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
					int _ObjectId;
					int _PassValue;
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
					float4 _SelectionID;
					#endif
					
					#pragma fragment frag
					void frag(ps_input i
					#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
					    #ifdef WRITE_MSAA_DEPTH
					    // We need the depth color as SV_Target0 for alpha to coverage
					    , out float4 outDepthColor : SV_Target0
					    , out float4 outMotionVector : SV_Target1
					    #else
					    // When no MSAA, the motion vector is always the first buffer
					    , out float4 outMotionVector : SV_Target0
					    #endif
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
					    #if defined(WRITE_MSAA_DEPTH)
						#if defined(WRITE_NORMAL_BUFFER)
						#error Unexpected depth setup mssa + depth normal
						#endif
					    , out float4 outDepthColor : SV_Target0
					    #elif defined(WRITE_NORMAL_BUFFER)
						, out float4 outNormalBuffer : SV_Target0
						#else
					    , out float4 dummy : SV_Target0
					    #endif
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
					    , out float4 outSelection : SV_Target0
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
					    , out float4 dummy : SV_Target0
					#endif
					)
					{
						UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
						VFXTransformPSInputs(i);
						
									#ifdef VFX_VARYING_NORMAL
									#if USE_DOUBLE_SIDED
									const float faceMul = frontFace ? 1.0f : -1.0f;
									#else
									const float faceMul = 1.0f;
									#endif
									
									float3 normalWS = normalize(i.VFX_VARYING_NORMAL * faceMul);
									const VFXUVData uvData = GetUVData(i);
									
									#ifdef VFX_VARYING_TANGENT
									float3 tangentWS = normalize(i.VFX_VARYING_TANGENT.xyz);
									float3 bitangentWS = cross(normalWS,tangentWS) * (i.VFX_VARYING_TANGENT.w * faceMul);
									float3x3 tbn = float3x3(tangentWS,bitangentWS,normalWS);
									
									#if USE_NORMAL_MAP
									float3 n = SampleNormalMap(VFX_SAMPLER(normalMap),uvData);
									float normalScale = 1.0f;
									#ifdef VFX_VARYING_NORMALSCALE
									normalScale = i.VFX_VARYING_NORMALSCALE;
									#endif
									normalWS = normalize(lerp(normalWS,mul(n,tbn),normalScale));
									#endif
									#endif
									#endif
									
					
					    #ifdef VFX_SHADERGRAPH
					        
							#if (SHADERPASS == SHADERPASS_DEPTHNORMALSONLY)
							
							#else
							
							#endif
					        float alpha = OUTSG.;
					    #else
					        float alpha = VFXGetFragmentColor(i).a;
							#if VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH
								#ifdef VFX_PROCEDURAL_UV
									alpha *= VFXGetTextureColorWithProceduralUV(VFX_SAMPLER(mainTexture),i,VFX_PROCEDURAL_UV(i)).a;
								#else
									alpha *= VFXGetTextureColor(VFX_SAMPLER(mainTexture),i).a;
								#endif
							#endif
					    #endif
						VFXClipFragmentColor(alpha,i);
					
						#ifdef WRITE_MSAA_DEPTH
							outDepthColor = i.VFX_VARYING_POSCS.z;
							#if VFX_USE_ALPHA_TO_MASK
								outDepthColor.a = alpha;
							#endif
						#endif
					
						#ifdef WRITE_NORMAL_BUFFER
							#ifdef VFX_VARYING_NORMAL
								VFXComputePixelOutputToNormalBuffer(i, normalWS, GetUVData(i), outNormalBuffer);
							#else
								//Fallback for point and lines, render normal as if those are face camera plane
								VFXComputePixelOutputToNormalBuffer(i, VFXGetWorldToViewRotMatrix()[2], GetUVData(i), outNormalBuffer);
							#endif
						#endif
					
						#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
							
									
									//No w division with fast path of motion vectors
									#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
									float2 velocity = i.VFX_VARYING_VELOCITY_CPOS - i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS;
									#else
									float2 velocity = (i.VFX_VARYING_VELOCITY_CPOS.xy/i.VFX_VARYING_VELOCITY_CPOS.w) - (i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.xy/i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.w);
									#endif
									
									#if UNITY_UV_STARTS_AT_TOP
										velocity.y = -velocity.y;
									#endif
									float4 encodedMotionVector = 0.0f;
									VFXEncodeMotionVector(velocity * 0.5f, encodedMotionVector);
									
							outMotionVector = encodedMotionVector;
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
							outSelection = float4(_ObjectId, _PassValue, 1.0, 1.0);
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
							outSelection = _SelectionID;
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
							#if !defined(WRITE_MSAA_DEPTH) && !defined(WRITE_NORMAL_BUFFER)
							    dummy = float4(i.VFX_VARYING_POSCS.z, 0,0,0);
							#endif
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
							dummy = (float4)0;
						#else
							#error VFX_PASSDEPTH undefined
						#endif
					}
					
			
			
		
			ENDHLSL
		}
		
		Pass
		{
		    Name "Picking"
			Tags { "LightMode"="Picking" }
		
			ZWrite On
			Blend Off
		
			HLSLPROGRAM
			#define VFX_PASSDEPTH VFX_PASSDEPTH_PICKING
			#pragma target 4.5
			
			#if SHADERGRAPH_NEEDS_NORMAL_DEPTHONLY || defined(WRITE_NORMAL_BUFFER) || FORCE_NORMAL_OUTPUT_UNLIT_VERTEX_SHADER
			#define NEEDS_NORMAL 1
			#endif
			
			#if SHADERGRAPH_NEEDS_TANGENT_DEPTHONLY
			#define NEEDS_TANGENT 1
			#endif
			
			struct ps_input
			{
				float4 pos : SV_POSITION;
				#if USE_FLIPBOOK_INTERPOLATION
				float4 uv : TEXCOORD0;
				#else
				#if USE_FLIPBOOK_ARRAY_LAYOUT
				float3 uv : TEXCOORD0;
				#else
				float2 uv : TEXCOORD0;
				#endif
				#endif
			    #if VFX_SHADERGRAPH_HAS_UV1
			    float4 uv1 : TEXCOORD1;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV2
			    float4 uv2 : TEXCOORD2;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV3
			    float4 uv3 : TEXCOORD3;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_COLOR
			    float4 vertexColor : COLOR;
			    #endif
				#if USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION || VFX_USE_ALPHA_CURRENT
				// x: alpha threshold
				// y: frame blending factor
				// z: alpha
				nointerpolation float3 builtInInterpolants : TEXCOORD4;
				#endif
			
				#if USE_FLIPBOOK_MOTIONVECTORS
				// x: motion vectors scale X
				// y: motion vectors scale Y
				nointerpolation float2 builtInInterpolants2 : TEXCOORD5;
				#endif
			
			    #if VFX_NEEDS_POSWS_INTERPOLATOR
				float3 posWS : TEXCOORD6;
			    #endif
			
				#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
				VFX_DECLARE_MOTION_VECTORS_STORAGE(7,8)
				#endif
			    
			
			    #if NEEDS_NORMAL
			    float3 normal : TEXCOORD9;
			    #endif
			
			    #if NEEDS_TANGENT
			    float4 tangent : TEXCOORD10;
			    #endif
			
				UNITY_VERTEX_OUTPUT_STEREO
			
			    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
			};
			
			#define VFX_VARYING_PS_INPUTS ps_input
			#define VFX_VARYING_POSCS pos
			#define VFX_VARYING_ALPHA builtInInterpolants.z
			#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.x
			#define VFX_VARYING_FRAMEBLEND builtInInterpolants.y
			#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
			#define VFX_VARYING_UV uv
			
			#if VFX_NEEDS_POSWS_INTERPOLATOR
			#define VFX_VARYING_POSWS posWS
			#endif
			
			#if NEEDS_NORMAL
			#define VFX_VARYING_NORMAL normal
			#endif
			
			#if NEEDS_TANGENT
			#define VFX_VARYING_TANGENT tangent
			#endif
			
			#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
			#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
			#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
			#endif
			
			#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
			#define SHADERPASS SHADERPASS_MOTION_VECTORS
			#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL || VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
			
					#if defined(WRITE_NORMAL_BUFFER)
					#define SHADERPASS SHADERPASS_DEPTHNORMALSONLY
					#else
					#define SHADERPASS SHADERPASS_DEPTHONLY
					#endif
					
			#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
			#define SHADERPASS SHADERPASS_SHADOWS
			#endif
			
			#if !(defined(VFX_VARYING_PS_INPUTS) && defined(VFX_VARYING_POSCS))
			#error VFX_VARYING_PS_INPUTS, VFX_VARYING_POSCS and VFX_VARYING_UV must be defined.
			#endif
			
			#include "Packages/com.unity.render-pipelines.universal/Runtime/VFXGraph/Shaders/VFXCommon.hlsl"
			#include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.hlsl"
			#include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommonOutput.hlsl"
			

			void SetAttribute_3278B22F(inout float size, float _Size) /*channels:XYZ */
			{
			    size = _Size;
			}
			

			
			struct vs_input
			{
				float3 pos : POSITION;
				float2 uv : TEXCOORD0;
			    #if VFX_SHADERGRAPH_HAS_UV1
			    float4 uv1 : TEXCOORD1;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV2
			    float4 uv2 : TEXCOORD2;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV3
			    float4 uv3 : TEXCOORD3;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_COLOR
			    float4 vertexColor : COLOR;
			    #endif
				float3 normal : NORMAL;
				#if defined(VFX_VARYING_TANGENT) || SHADERGRAPH_HAS_NORMAL
				float4 tangent : TANGENT;
				#endif
				VFX_DECLARE_INSTANCE_ID
			};
			
			#pragma vertex vert
			VFX_VARYING_PS_INPUTS vert(vs_input i)
			{
			    VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;
			
				UNITY_SETUP_INSTANCE_ID(i);
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
			
				uint index = VFX_GET_INSTANCE_ID(i);
			
				
						uint instanceIndex, instanceActiveIndex, instanceCurrentIndex;
						index = VFXInitInstancing(index, instanceIndex, instanceActiveIndex, instanceCurrentIndex);
						
				
			
				struct ContextData
				{
				    uint maxParticleCount;
				    uint systemSeed;
				    uint initSpawnIndex;
				};
				ContextData contextData;
				uint4 rawContextData = graphValuesBuffer.Load4(instanceActiveIndex * 160);
				contextData.maxParticleCount = rawContextData.x;
				contextData.systemSeed = rawContextData.y;
				contextData.initSpawnIndex = rawContextData.z;
				

				uint systemSeed = contextData.systemSeed;
				uint nbMax = contextData.maxParticleCount;
			
				
						#if HAS_STRIPS && !VFX_HAS_INDIRECT_DRAW
							// We render one particle less for each strip in this case
							nbMax -= STRIP_COUNT;
						#endif
						
						uint deadCount = 0;
						#if USE_DEAD_LIST_COUNT
						deadCount = deadList[instanceIndex];
						#endif
						#if VFX_USE_INSTANCING
						if (index >= nbMax - deadCount)
						#else
						if (index >= asuint(nbMax) - deadCount)
						#endif
						{
							CULL_VERTEX(o);
						}
						
						VFXAttributes attributes = (VFXAttributes)0;
						VFXSourceAttributes sourceAttributes = (VFXSourceAttributes)0;
						
						#if VFX_HAS_INDIRECT_DRAW
						if (index >= indirectBuffer[instanceActiveIndex])
						{
							CULL_VERTEX(o);
						}
						index = indirectBuffer[VFXGetIndirectBufferIndex(index, instanceActiveIndex)];
						#endif
						
						#if HAS_STRIPS_DATA
						StripData stripData;
						uint relativeIndexInStrip = 0;
						if (!FindIndexInStrip(index, id, instanceIndex, relativeIndexInStrip, stripData))
						{
							CULL_VERTEX(o);
						}
						#endif
						
						#if VFX_HAS_INDIRECT_DRAW
						attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x140) + (index * 0x4 + 0x20)) << 2));
						attributes.angleX = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA0)) << 2));
						attributes.angleY = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA1)) << 2));
						attributes.angleZ = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA2)) << 2));
						attributes.color = float3(1, 1, 1);
						attributes.alpha = (float)1;
						attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x1 + 0x100)) << 2));
						attributes.axisX = float3(1, 0, 0);
						attributes.axisY = float3(0, 1, 0);
						attributes.axisZ = float3(0, 0, 1);
						attributes.pivotX = (float)0;
						attributes.pivotY = (float)0;
						attributes.pivotZ = (float)0;
						attributes.size = (float)0.100000001;
						attributes.scaleX = (float)1;
						attributes.scaleY = (float)1;
						attributes.scaleZ = (float)1;
						
				
						#else
						attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x1 + 0x100)) << 2));
						
				
						#if !HAS_STRIPS
						if (!attributes.alive)
						{
							CULL_VERTEX(o);
						}
						#endif
						
						attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x140) + (index * 0x4 + 0x20)) << 2));
						attributes.angleX = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA0)) << 2));
						attributes.angleY = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA1)) << 2));
						attributes.angleZ = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA2)) << 2));
						attributes.color = float3(1, 1, 1);
						attributes.alpha = (float)1;
						attributes.axisX = float3(1, 0, 0);
						attributes.axisY = float3(0, 1, 0);
						attributes.axisZ = float3(0, 0, 1);
						attributes.pivotX = (float)0;
						attributes.pivotY = (float)0;
						attributes.pivotZ = (float)0;
						attributes.size = (float)0.100000001;
						attributes.scaleX = (float)1;
						attributes.scaleY = (float)1;
						attributes.scaleZ = (float)1;
						
				
						#endif
						
						// Initialize built-in needed attributes
						#if HAS_STRIPS_DATA
						InitStripAttributes(index, attributes, stripData);
						#endif
						
				{
				    SetAttribute_3278B22F( /*inout */attributes.size, (float)0.100000001);
				}
				

			
				if (!attributes.alive)
					return o;
			
			    #ifdef VFX_VARYING_UV
			    o.VFX_VARYING_UV.xy = i.uv;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV1
			    o.uv1 = i.uv1;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV2
			    o.uv2 = i.uv2;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV3
			    o.uv3 = i.uv3;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_COLOR
			    o.vertexColor = i.vertexColor;
			    #endif
			
				
						float3 size3 = float3(attributes.size,attributes.size,attributes.size);
						#if VFX_USE_SCALEX_CURRENT
						size3.x *= attributes.scaleX;
						#endif
						#if VFX_USE_SCALEY_CURRENT
						size3.y *= attributes.scaleY;
						#endif
						#if VFX_USE_SCALEZ_CURRENT
						size3.z *= attributes.scaleZ;
						#endif
						
			
				float3 inputVertexPosition = i.pos;
				float4x4 elementToVFX = GetElementToVFXMatrix(
					attributes.axisX,
					attributes.axisY,
					attributes.axisZ,
					float3(attributes.angleX,attributes.angleY,attributes.angleZ),
					float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
					size3,
					attributes.position);
			
				float3 vPos = mul(elementToVFX,float4(inputVertexPosition,1.0f)).xyz;
				float4 csPos = TransformPositionVFXToClip(vPos);
				o.VFX_VARYING_POSCS = csPos;
			
				// TODO This is needed only if in local space (to handle non uniform scale) or if scale attributes are stored/written (no way to know atm)
				float3x3 elementToVFX_N = GetElementToVFXMatrixNormal(
					attributes.axisX,
					attributes.axisY,
					attributes.axisZ,
					float3(attributes.angleX,attributes.angleY,attributes.angleZ),
					size3);
			
				float3 normalWS = normalize(TransformNormalVFXToWorld(mul(elementToVFX_N, i.normal)));
				#ifdef VFX_VARYING_NORMAL
				float normalFlip = (size3.x * size3.y * size3.z) < 0 ? -1 : 1;
				o.VFX_VARYING_NORMAL = normalFlip * normalWS;
				#endif
				#ifdef VFX_VARYING_TANGENT
				o.VFX_VARYING_TANGENT = float4(normalize(TransformDirectionVFXToWorld(mul((float3x3)elementToVFX,i.tangent.xyz))),i.tangent.w);
				#endif
			
				
						#if VFX_FEATURE_MOTION_VECTORS && defined(VFX_VARYING_VELOCITY_CPOS_PREVIOUS) && defined(VFX_VARYING_VELOCITY_CPOS)
						
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = (float2)0.0f;
						#else
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = float4(0.0f, 0.0f, 0.0f, 1.0f);
						#endif
						
						
						uint elementToVFXBaseIndex;
						if (TryGetElementToVFXBaseIndex(index, instanceIndex, elementToVFXBaseIndex, currentFrameIndex))
						{
						float4 cPos = TransformPositionVFXToNonJitteredClip(vPos);
						
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = VFXGetPreviousClipPosition(elementToVFXBaseIndex, id).xy;
							o.VFX_VARYING_VELOCITY_CPOS = cPos.xy / cPos.w;
						#else
							float4x4 previousElementToVFX = VFXGetPreviousElementToVFX(elementToVFXBaseIndex);
							float3 oldvPos = mul(previousElementToVFX, float4(inputVertexPosition, 1.0f)).xyz;
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = TransformPositionVFXToPreviousClip(oldvPos);
							o.VFX_VARYING_VELOCITY_CPOS = cPos;
						#endif
						
						}
						#endif
						
			
				
						#if VFX_USE_COLOR_CURRENT && defined(VFX_VARYING_COLOR)
						o.VFX_VARYING_COLOR = attributes.color;
						#endif
						#if VFX_USE_ALPHA_CURRENT && defined(VFX_VARYING_ALPHA)
						o.VFX_VARYING_ALPHA = attributes.alpha;
						#endif
						
						#ifdef VFX_VARYING_EXPOSUREWEIGHT
						
						o.VFX_VARYING_EXPOSUREWEIGHT = exposureWeight;
						#endif
						
						#if USE_SOFT_PARTICLE && defined(VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE)
						
						o.VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE = invSoftParticlesFadeDistance;
						#endif
						
						#if (USE_ALPHA_TEST || VFX_FEATURE_MOTION_VECTORS_FORWARD) && (!VFX_SHADERGRAPH || !HAS_SHADERGRAPH_PARAM_ALPHACLIPTHRESHOLD) && defined(VFX_VARYING_ALPHATHRESHOLD)
						
						o.VFX_VARYING_ALPHATHRESHOLD = alphaThreshold;
						#endif
						
						#if USE_UV_SCALE_BIAS
						
						
						#if defined (VFX_VARYING_UV)
						o.VFX_VARYING_UV.xy = o.VFX_VARYING_UV.xy * uvScale + uvBias;
						#endif
						#endif
						
						#ifdef VFX_VARYING_ANGLEFADE
						
						o.VFX_VARYING_ANGLEFADE = angleFade;
						#endif
						
						#ifdef VFX_VARYING_FADEFACTOR
						
						o.VFX_VARYING_FADEFACTOR = fadeFactor;
						#endif
						
						#ifdef VFX_VARYING_DECALLAYER
						
						o.VFX_VARYING_DECALLAYER = decalLayerMask;
						#endif
						
						#if defined(VFX_VARYING_POSWS)
						o.VFX_VARYING_POSWS = TransformPositionVFXToWorld(vPos);
						#endif
						
						#if VFX_USE_INSTANCING
						    #ifdef UNITY_INSTANCING_ENABLED
						    o.VFX_VARYINGS_INSTANCE_CURRENT_INDEX = unity_InstanceID;
						    #endif
						o.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX = instanceActiveIndex;
						#endif
						
			
				
						#if USE_FLIPBOOK && defined(VFX_VARYING_UV)
							#if USE_FLIPBOOK_ARRAY_LAYOUT
								
								#if USE_FLIPBOOK_INTERPOLATION
									VFXUVData uvData = GetUVData(flipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex, attributes.texIndexBlend);
								#else
									VFXUVData uvData = GetUVData(flipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex);
								#endif
								o.VFX_VARYING_UV.xyz = uvData.uvs.xyz;
								#if USE_FLIPBOOK_INTERPOLATION && defined(VFX_VARYING_UV) && defined (VFX_VARYING_FRAMEBLEND)
									o.VFX_VARYING_UV.w = uvData.uvs.w;
									o.VFX_VARYING_FRAMEBLEND = uvData.blend;
									#if USE_FLIPBOOK_MOTIONVECTORS && defined(VFX_VARYING_MOTIONVECTORSCALE)
										
										o.VFX_VARYING_MOTIONVECTORSCALE = motionVectorScale;
									#endif
								#endif
							#else
								
								
								#if USE_FLIPBOOK_INTERPOLATION
									VFXUVData uvData = GetUVData(flipBookSize, invFlipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex, attributes.texIndexBlend);
								#else
									VFXUVData uvData = GetUVData(flipBookSize, invFlipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex);
								#endif
								o.VFX_VARYING_UV.xy = uvData.uvs.xy;
								#if USE_FLIPBOOK_INTERPOLATION && defined(VFX_VARYING_UV) && defined (VFX_VARYING_FRAMEBLEND)
									o.VFX_VARYING_UV.zw = uvData.uvs.zw;
									o.VFX_VARYING_FRAMEBLEND = uvData.blend;
									#if USE_FLIPBOOK_MOTIONVECTORS && defined(VFX_VARYING_MOTIONVECTORSCALE)
										
										o.VFX_VARYING_MOTIONVECTORSCALE = motionVectorScale * invFlipBookSize;
									#endif
								#endif
							#endif
						#endif
						
			
				
			
			    
			
				return o;
			}
			
			
			
			
			
			
			#define VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH 1
			
					
					#ifndef VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH
					#define VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH 0
					#endif
					
					#ifdef VFX_SHADERGRAPH
						#if (SHADERPASS == SHADERPASS_DEPTHNORMALSONLY)
						
						#else
						
						#endif
					#endif
					
					#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
					int _ObjectId;
					int _PassValue;
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
					float4 _SelectionID;
					#endif
					
					#pragma fragment frag
					void frag(ps_input i
					#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
					    #ifdef WRITE_MSAA_DEPTH
					    // We need the depth color as SV_Target0 for alpha to coverage
					    , out float4 outDepthColor : SV_Target0
					    , out float4 outMotionVector : SV_Target1
					    #else
					    // When no MSAA, the motion vector is always the first buffer
					    , out float4 outMotionVector : SV_Target0
					    #endif
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
					    #if defined(WRITE_MSAA_DEPTH)
						#if defined(WRITE_NORMAL_BUFFER)
						#error Unexpected depth setup mssa + depth normal
						#endif
					    , out float4 outDepthColor : SV_Target0
					    #elif defined(WRITE_NORMAL_BUFFER)
						, out float4 outNormalBuffer : SV_Target0
						#else
					    , out float4 dummy : SV_Target0
					    #endif
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
					    , out float4 outSelection : SV_Target0
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
					    , out float4 dummy : SV_Target0
					#endif
					)
					{
						UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
						VFXTransformPSInputs(i);
						
									#ifdef VFX_VARYING_NORMAL
									#if USE_DOUBLE_SIDED
									const float faceMul = frontFace ? 1.0f : -1.0f;
									#else
									const float faceMul = 1.0f;
									#endif
									
									float3 normalWS = normalize(i.VFX_VARYING_NORMAL * faceMul);
									const VFXUVData uvData = GetUVData(i);
									
									#ifdef VFX_VARYING_TANGENT
									float3 tangentWS = normalize(i.VFX_VARYING_TANGENT.xyz);
									float3 bitangentWS = cross(normalWS,tangentWS) * (i.VFX_VARYING_TANGENT.w * faceMul);
									float3x3 tbn = float3x3(tangentWS,bitangentWS,normalWS);
									
									#if USE_NORMAL_MAP
									float3 n = SampleNormalMap(VFX_SAMPLER(normalMap),uvData);
									float normalScale = 1.0f;
									#ifdef VFX_VARYING_NORMALSCALE
									normalScale = i.VFX_VARYING_NORMALSCALE;
									#endif
									normalWS = normalize(lerp(normalWS,mul(n,tbn),normalScale));
									#endif
									#endif
									#endif
									
					
					    #ifdef VFX_SHADERGRAPH
					        
							#if (SHADERPASS == SHADERPASS_DEPTHNORMALSONLY)
							
							#else
							
							#endif
					        float alpha = OUTSG.;
					    #else
					        float alpha = VFXGetFragmentColor(i).a;
							#if VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH
								#ifdef VFX_PROCEDURAL_UV
									alpha *= VFXGetTextureColorWithProceduralUV(VFX_SAMPLER(mainTexture),i,VFX_PROCEDURAL_UV(i)).a;
								#else
									alpha *= VFXGetTextureColor(VFX_SAMPLER(mainTexture),i).a;
								#endif
							#endif
					    #endif
						VFXClipFragmentColor(alpha,i);
					
						#ifdef WRITE_MSAA_DEPTH
							outDepthColor = i.VFX_VARYING_POSCS.z;
							#if VFX_USE_ALPHA_TO_MASK
								outDepthColor.a = alpha;
							#endif
						#endif
					
						#ifdef WRITE_NORMAL_BUFFER
							#ifdef VFX_VARYING_NORMAL
								VFXComputePixelOutputToNormalBuffer(i, normalWS, GetUVData(i), outNormalBuffer);
							#else
								//Fallback for point and lines, render normal as if those are face camera plane
								VFXComputePixelOutputToNormalBuffer(i, VFXGetWorldToViewRotMatrix()[2], GetUVData(i), outNormalBuffer);
							#endif
						#endif
					
						#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
							
									
									//No w division with fast path of motion vectors
									#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
									float2 velocity = i.VFX_VARYING_VELOCITY_CPOS - i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS;
									#else
									float2 velocity = (i.VFX_VARYING_VELOCITY_CPOS.xy/i.VFX_VARYING_VELOCITY_CPOS.w) - (i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.xy/i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.w);
									#endif
									
									#if UNITY_UV_STARTS_AT_TOP
										velocity.y = -velocity.y;
									#endif
									float4 encodedMotionVector = 0.0f;
									VFXEncodeMotionVector(velocity * 0.5f, encodedMotionVector);
									
							outMotionVector = encodedMotionVector;
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
							outSelection = float4(_ObjectId, _PassValue, 1.0, 1.0);
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
							outSelection = _SelectionID;
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
							#if !defined(WRITE_MSAA_DEPTH) && !defined(WRITE_NORMAL_BUFFER)
							    dummy = float4(i.VFX_VARYING_POSCS.z, 0,0,0);
							#endif
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
							dummy = (float4)0;
						#else
							#error VFX_PASSDEPTH undefined
						#endif
					}
					
			
			
		
			ENDHLSL
		}
		
		

		
		
		
		// Forward pass
		Pass
		{
		    Name "UniversalForwardOnly"
			Tags { "LightMode"="UniversalForwardOnly" }
		
			
		
			HLSLPROGRAM
			#pragma target 4.5
			
					#pragma multi_compile_fragment _ _SCREEN_SPACE_OCCLUSION
					#pragma multi_compile _ DEBUG_DISPLAY
					#pragma multi_compile_fog
					#include_with_pragmas "Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRenderingKeywords.hlsl"
					#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Debug/Debugging3D.hlsl"
					
		
			struct ps_input
			{
				float4 pos : SV_POSITION;
				#if USE_FLIPBOOK_INTERPOLATION
				float4 uv : TEXCOORD0;
				#else
					#if USE_FLIPBOOK_ARRAY_LAYOUT
					float3 uv : TEXCOORD0;
					#else
					float2 uv : TEXCOORD0;
					#endif
				#endif
				#if VFX_SHADERGRAPH_HAS_UV1
				float4 uv1 : TEXCOORD1;
				#endif
				#if VFX_SHADERGRAPH_HAS_UV2
				float4 uv2 : TEXCOORD2;
				#endif
				#if VFX_SHADERGRAPH_HAS_UV3
				float4 uv3 : TEXCOORD3;
				#endif
				#if VFX_SHADERGRAPH_HAS_COLOR
				float4 vertexColor : COLOR1;
				#endif
				#if VFX_NEEDS_COLOR_INTERPOLATOR
				nointerpolation float4 color : COLOR0;
				#endif
				#if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION || USE_EXPOSURE_WEIGHT || VFX_FEATURE_MOTION_VECTORS_FORWARD
				// x: inverse soft particles fade distance
				// y: alpha threshold
				// z: frame blending factor
				// w: exposure weight
				nointerpolation float4 builtInInterpolants : TEXCOORD4;
				#endif
				#if USE_FLIPBOOK_MOTIONVECTORS
				// x: motion vectors scale X
				// y: motion vectors scale Y
				nointerpolation float2 builtInInterpolants2 : TEXCOORD5;
				#endif
				#if VFX_NEEDS_POSWS_INTERPOLATOR
				float3 posWS : TEXCOORD6;
				#endif
			
				#if VFX_FEATURE_MOTION_VECTORS_FORWARD
				VFX_DECLARE_MOTION_VECTORS_STORAGE(7,8)
				#endif
			
				#if SHADERGRAPH_NEEDS_NORMAL_FORWARD || FORCE_NORMAL_OUTPUT_UNLIT_VERTEX_SHADER
				float3 normal : TEXCOORD9;
				#endif
				#if SHADERGRAPH_NEEDS_TANGENT_FORWARD
				float4 tangent : TEXCOORD10;
				#endif
			
				
			
				UNITY_VERTEX_OUTPUT_STEREO
			
			    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
			};
			
			struct ps_output
			{
				float4 color : SV_Target0;
			#if VFX_FEATURE_MOTION_VECTORS_FORWARD
				float4 outMotionVector : SV_Target1;
			#endif
			};
			
			#define VFX_VARYING_PS_INPUTS ps_input
			#define VFX_VARYING_POSCS pos
			#define VFX_VARYING_COLOR color.rgb
			#define VFX_VARYING_ALPHA color.a
			#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
			#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
			#define VFX_VARYING_FRAMEBLEND builtInInterpolants.z
			#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
			#define VFX_VARYING_UV uv
			#if VFX_NEEDS_POSWS_INTERPOLATOR
			#define VFX_VARYING_POSWS posWS
			#endif
			#if USE_EXPOSURE_WEIGHT
			#define VFX_VARYING_EXPOSUREWEIGHT builtInInterpolants.w
			#endif
			#if VFX_FEATURE_MOTION_VECTORS_FORWARD
			#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
			#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
			#endif
			
			
			
			#if SHADERGRAPH_NEEDS_NORMAL_FORWARD || FORCE_NORMAL_OUTPUT_UNLIT_VERTEX_SHADER
			#define VFX_VARYING_NORMAL normal
			#endif
			#if SHADERGRAPH_NEEDS_TANGENT_FORWARD
			#define VFX_VARYING_TANGENT tangent
			#endif
			
			#if !(defined(VFX_VARYING_PS_INPUTS) && defined(VFX_VARYING_POSCS))
			#error VFX_VARYING_PS_INPUTS, VFX_VARYING_POSCS and VFX_VARYING_UV must be defined.
			#endif
			
			#include "Packages/com.unity.render-pipelines.universal/Runtime/VFXGraph/Shaders/VFXCommon.hlsl"
			#include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.hlsl"
			#include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommonOutput.hlsl"
			

			void SetAttribute_3278B22F(inout float size, float _Size) /*channels:XYZ */
			{
			    size = _Size;
			}
			

			
			struct vs_input
			{
				float3 pos : POSITION;
				float2 uv : TEXCOORD0;
			    #if VFX_SHADERGRAPH_HAS_UV1
			    float4 uv1 : TEXCOORD1;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV2
			    float4 uv2 : TEXCOORD2;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV3
			    float4 uv3 : TEXCOORD3;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_COLOR
			    float4 vertexColor : COLOR;
			    #endif
				float3 normal : NORMAL;
				#if defined(VFX_VARYING_TANGENT) || SHADERGRAPH_HAS_NORMAL
				float4 tangent : TANGENT;
				#endif
				VFX_DECLARE_INSTANCE_ID
			};
			
			#pragma vertex vert
			VFX_VARYING_PS_INPUTS vert(vs_input i)
			{
			    VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;
			
				UNITY_SETUP_INSTANCE_ID(i);
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
			
				uint index = VFX_GET_INSTANCE_ID(i);
			
				
						uint instanceIndex, instanceActiveIndex, instanceCurrentIndex;
						index = VFXInitInstancing(index, instanceIndex, instanceActiveIndex, instanceCurrentIndex);
						
				
			
				struct ContextData
				{
				    uint maxParticleCount;
				    uint systemSeed;
				    uint initSpawnIndex;
				};
				ContextData contextData;
				uint4 rawContextData = graphValuesBuffer.Load4(instanceActiveIndex * 160);
				contextData.maxParticleCount = rawContextData.x;
				contextData.systemSeed = rawContextData.y;
				contextData.initSpawnIndex = rawContextData.z;
				

				uint systemSeed = contextData.systemSeed;
				uint nbMax = contextData.maxParticleCount;
			
				
						#if HAS_STRIPS && !VFX_HAS_INDIRECT_DRAW
							// We render one particle less for each strip in this case
							nbMax -= STRIP_COUNT;
						#endif
						
						uint deadCount = 0;
						#if USE_DEAD_LIST_COUNT
						deadCount = deadList[instanceIndex];
						#endif
						#if VFX_USE_INSTANCING
						if (index >= nbMax - deadCount)
						#else
						if (index >= asuint(nbMax) - deadCount)
						#endif
						{
							CULL_VERTEX(o);
						}
						
						VFXAttributes attributes = (VFXAttributes)0;
						VFXSourceAttributes sourceAttributes = (VFXSourceAttributes)0;
						
						#if VFX_HAS_INDIRECT_DRAW
						if (index >= indirectBuffer[instanceActiveIndex])
						{
							CULL_VERTEX(o);
						}
						index = indirectBuffer[VFXGetIndirectBufferIndex(index, instanceActiveIndex)];
						#endif
						
						#if HAS_STRIPS_DATA
						StripData stripData;
						uint relativeIndexInStrip = 0;
						if (!FindIndexInStrip(index, id, instanceIndex, relativeIndexInStrip, stripData))
						{
							CULL_VERTEX(o);
						}
						#endif
						
						#if VFX_HAS_INDIRECT_DRAW
						attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x140) + (index * 0x4 + 0x20)) << 2));
						attributes.angleX = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA0)) << 2));
						attributes.angleY = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA1)) << 2));
						attributes.angleZ = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA2)) << 2));
						attributes.color = float3(1, 1, 1);
						attributes.alpha = (float)1;
						attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x1 + 0x100)) << 2));
						attributes.axisX = float3(1, 0, 0);
						attributes.axisY = float3(0, 1, 0);
						attributes.axisZ = float3(0, 0, 1);
						attributes.pivotX = (float)0;
						attributes.pivotY = (float)0;
						attributes.pivotZ = (float)0;
						attributes.size = (float)0.100000001;
						attributes.scaleX = (float)1;
						attributes.scaleY = (float)1;
						attributes.scaleZ = (float)1;
						
				
						#else
						attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x1 + 0x100)) << 2));
						
				
						#if !HAS_STRIPS
						if (!attributes.alive)
						{
							CULL_VERTEX(o);
						}
						#endif
						
						attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x140) + (index * 0x4 + 0x20)) << 2));
						attributes.angleX = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA0)) << 2));
						attributes.angleY = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA1)) << 2));
						attributes.angleZ = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA2)) << 2));
						attributes.color = float3(1, 1, 1);
						attributes.alpha = (float)1;
						attributes.axisX = float3(1, 0, 0);
						attributes.axisY = float3(0, 1, 0);
						attributes.axisZ = float3(0, 0, 1);
						attributes.pivotX = (float)0;
						attributes.pivotY = (float)0;
						attributes.pivotZ = (float)0;
						attributes.size = (float)0.100000001;
						attributes.scaleX = (float)1;
						attributes.scaleY = (float)1;
						attributes.scaleZ = (float)1;
						
				
						#endif
						
						// Initialize built-in needed attributes
						#if HAS_STRIPS_DATA
						InitStripAttributes(index, attributes, stripData);
						#endif
						
				{
				    SetAttribute_3278B22F( /*inout */attributes.size, (float)0.100000001);
				}
				

			
				if (!attributes.alive)
					return o;
			
			    #ifdef VFX_VARYING_UV
			    o.VFX_VARYING_UV.xy = i.uv;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV1
			    o.uv1 = i.uv1;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV2
			    o.uv2 = i.uv2;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV3
			    o.uv3 = i.uv3;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_COLOR
			    o.vertexColor = i.vertexColor;
			    #endif
			
				
						float3 size3 = float3(attributes.size,attributes.size,attributes.size);
						#if VFX_USE_SCALEX_CURRENT
						size3.x *= attributes.scaleX;
						#endif
						#if VFX_USE_SCALEY_CURRENT
						size3.y *= attributes.scaleY;
						#endif
						#if VFX_USE_SCALEZ_CURRENT
						size3.z *= attributes.scaleZ;
						#endif
						
			
				float3 inputVertexPosition = i.pos;
				float4x4 elementToVFX = GetElementToVFXMatrix(
					attributes.axisX,
					attributes.axisY,
					attributes.axisZ,
					float3(attributes.angleX,attributes.angleY,attributes.angleZ),
					float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
					size3,
					attributes.position);
			
				float3 vPos = mul(elementToVFX,float4(inputVertexPosition,1.0f)).xyz;
				float4 csPos = TransformPositionVFXToClip(vPos);
				o.VFX_VARYING_POSCS = csPos;
			
				// TODO This is needed only if in local space (to handle non uniform scale) or if scale attributes are stored/written (no way to know atm)
				float3x3 elementToVFX_N = GetElementToVFXMatrixNormal(
					attributes.axisX,
					attributes.axisY,
					attributes.axisZ,
					float3(attributes.angleX,attributes.angleY,attributes.angleZ),
					size3);
			
				float3 normalWS = normalize(TransformNormalVFXToWorld(mul(elementToVFX_N, i.normal)));
				#ifdef VFX_VARYING_NORMAL
				float normalFlip = (size3.x * size3.y * size3.z) < 0 ? -1 : 1;
				o.VFX_VARYING_NORMAL = normalFlip * normalWS;
				#endif
				#ifdef VFX_VARYING_TANGENT
				o.VFX_VARYING_TANGENT = float4(normalize(TransformDirectionVFXToWorld(mul((float3x3)elementToVFX,i.tangent.xyz))),i.tangent.w);
				#endif
			
				
						#if VFX_FEATURE_MOTION_VECTORS && defined(VFX_VARYING_VELOCITY_CPOS_PREVIOUS) && defined(VFX_VARYING_VELOCITY_CPOS)
						
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = (float2)0.0f;
						#else
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = float4(0.0f, 0.0f, 0.0f, 1.0f);
						#endif
						
						
						uint elementToVFXBaseIndex;
						if (TryGetElementToVFXBaseIndex(index, instanceIndex, elementToVFXBaseIndex, currentFrameIndex))
						{
						float4 cPos = TransformPositionVFXToNonJitteredClip(vPos);
						
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = VFXGetPreviousClipPosition(elementToVFXBaseIndex, id).xy;
							o.VFX_VARYING_VELOCITY_CPOS = cPos.xy / cPos.w;
						#else
							float4x4 previousElementToVFX = VFXGetPreviousElementToVFX(elementToVFXBaseIndex);
							float3 oldvPos = mul(previousElementToVFX, float4(inputVertexPosition, 1.0f)).xyz;
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = TransformPositionVFXToPreviousClip(oldvPos);
							o.VFX_VARYING_VELOCITY_CPOS = cPos;
						#endif
						
						}
						#endif
						
			
				
						#if VFX_USE_COLOR_CURRENT && defined(VFX_VARYING_COLOR)
						o.VFX_VARYING_COLOR = attributes.color;
						#endif
						#if VFX_USE_ALPHA_CURRENT && defined(VFX_VARYING_ALPHA)
						o.VFX_VARYING_ALPHA = attributes.alpha;
						#endif
						
						#ifdef VFX_VARYING_EXPOSUREWEIGHT
						
						o.VFX_VARYING_EXPOSUREWEIGHT = exposureWeight;
						#endif
						
						#if USE_SOFT_PARTICLE && defined(VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE)
						
						o.VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE = invSoftParticlesFadeDistance;
						#endif
						
						#if (USE_ALPHA_TEST || VFX_FEATURE_MOTION_VECTORS_FORWARD) && (!VFX_SHADERGRAPH || !HAS_SHADERGRAPH_PARAM_ALPHACLIPTHRESHOLD) && defined(VFX_VARYING_ALPHATHRESHOLD)
						
						o.VFX_VARYING_ALPHATHRESHOLD = alphaThreshold;
						#endif
						
						#if USE_UV_SCALE_BIAS
						
						
						#if defined (VFX_VARYING_UV)
						o.VFX_VARYING_UV.xy = o.VFX_VARYING_UV.xy * uvScale + uvBias;
						#endif
						#endif
						
						#ifdef VFX_VARYING_ANGLEFADE
						
						o.VFX_VARYING_ANGLEFADE = angleFade;
						#endif
						
						#ifdef VFX_VARYING_FADEFACTOR
						
						o.VFX_VARYING_FADEFACTOR = fadeFactor;
						#endif
						
						#ifdef VFX_VARYING_DECALLAYER
						
						o.VFX_VARYING_DECALLAYER = decalLayerMask;
						#endif
						
						#if defined(VFX_VARYING_POSWS)
						o.VFX_VARYING_POSWS = TransformPositionVFXToWorld(vPos);
						#endif
						
						#if VFX_USE_INSTANCING
						    #ifdef UNITY_INSTANCING_ENABLED
						    o.VFX_VARYINGS_INSTANCE_CURRENT_INDEX = unity_InstanceID;
						    #endif
						o.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX = instanceActiveIndex;
						#endif
						
			
				
						#if USE_FLIPBOOK && defined(VFX_VARYING_UV)
							#if USE_FLIPBOOK_ARRAY_LAYOUT
								
								#if USE_FLIPBOOK_INTERPOLATION
									VFXUVData uvData = GetUVData(flipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex, attributes.texIndexBlend);
								#else
									VFXUVData uvData = GetUVData(flipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex);
								#endif
								o.VFX_VARYING_UV.xyz = uvData.uvs.xyz;
								#if USE_FLIPBOOK_INTERPOLATION && defined(VFX_VARYING_UV) && defined (VFX_VARYING_FRAMEBLEND)
									o.VFX_VARYING_UV.w = uvData.uvs.w;
									o.VFX_VARYING_FRAMEBLEND = uvData.blend;
									#if USE_FLIPBOOK_MOTIONVECTORS && defined(VFX_VARYING_MOTIONVECTORSCALE)
										
										o.VFX_VARYING_MOTIONVECTORSCALE = motionVectorScale;
									#endif
								#endif
							#else
								
								
								#if USE_FLIPBOOK_INTERPOLATION
									VFXUVData uvData = GetUVData(flipBookSize, invFlipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex, attributes.texIndexBlend);
								#else
									VFXUVData uvData = GetUVData(flipBookSize, invFlipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex);
								#endif
								o.VFX_VARYING_UV.xy = uvData.uvs.xy;
								#if USE_FLIPBOOK_INTERPOLATION && defined(VFX_VARYING_UV) && defined (VFX_VARYING_FRAMEBLEND)
									o.VFX_VARYING_UV.zw = uvData.uvs.zw;
									o.VFX_VARYING_FRAMEBLEND = uvData.blend;
									#if USE_FLIPBOOK_MOTIONVECTORS && defined(VFX_VARYING_MOTIONVECTORSCALE)
										
										o.VFX_VARYING_MOTIONVECTORSCALE = motionVectorScale * invFlipBookSize;
									#endif
								#endif
							#endif
						#endif
						
			
				
			
			    
			
				return o;
			}
			
			
			
			
			
			
			
			
			
			#pragma fragment frag
			ps_output frag(ps_input i)
			{
				UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
				ps_output o = (ps_output)0;
				VFXTransformPSInputs(i);
			
			#if VFX_USE_GRAPH_VALUES
			    uint instanceActiveIndex = i.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX;
			    
			#endif
			
				
							#ifdef VFX_VARYING_NORMAL
							#if USE_DOUBLE_SIDED
							const float faceMul = frontFace ? 1.0f : -1.0f;
							#else
							const float faceMul = 1.0f;
							#endif
							
							float3 normalWS = normalize(i.VFX_VARYING_NORMAL * faceMul);
							const VFXUVData uvData = GetUVData(i);
							
							#ifdef VFX_VARYING_TANGENT
							float3 tangentWS = normalize(i.VFX_VARYING_TANGENT.xyz);
							float3 bitangentWS = cross(normalWS,tangentWS) * (i.VFX_VARYING_TANGENT.w * faceMul);
							float3x3 tbn = float3x3(tangentWS,bitangentWS,normalWS);
							
							#if USE_NORMAL_MAP
							float3 n = SampleNormalMap(VFX_SAMPLER(normalMap),uvData);
							float normalScale = 1.0f;
							#ifdef VFX_VARYING_NORMALSCALE
							normalScale = i.VFX_VARYING_NORMALSCALE;
							#endif
							normalWS = normalize(lerp(normalWS,mul(n,tbn),normalScale));
							#endif
							#endif
							#endif
							
			
				#if VFX_SHADERGRAPH
					
					
			
					#if HAS_SHADERGRAPH_PARAM_BASECOLOR
						o.color.rgb = OUTSG..rgb;
						o.color = VFXApplyPreExposure(o.color, i);
					#endif
			
					#if HAS_SHADERGRAPH_PARAM_EMISSION
						float4 emission = float4(OUTSG..rgb, 0.0f);
						emission = VFXApplyPreExposure(emission, 1.0f);
						o.color.rgb += emission.rgb;
					#endif
			
					#if HAS_SHADERGRAPH_PARAM_ALPHA
						o.color.a = OUTSG.;
					#endif
				#else
					#define VFX_TEXTURE_COLOR VFXGetTextureColor(VFX_SAMPLER(mainTexture),i)
					
							
							float4 color = VFXGetFragmentColor(i);
							
							#ifndef VFX_TEXTURE_COLOR
								#define VFX_TEXTURE_COLOR float4(1.0,1.0,1.0,1.0)
							#endif
							
							#if VFX_COLORMAPPING_DEFAULT
								o.color = color * VFX_TEXTURE_COLOR;
							#endif
							
							#if VFX_COLORMAPPING_GRADIENTMAPPED
								
								o.color = SampleGradient(gradient, VFX_TEXTURE_COLOR.a * color.a) * float4(color.rgb,1.0);
							#endif
							
							
					o.color = VFXApplyPreExposure(o.color, i);
				#endif
			
				o.color = VFXApplyAO(o.color,i);
				o.color = VFXApplyFog(o.color,i);
				VFXClipFragmentColor(o.color.a,i);
				o.color.a = saturate(o.color.a);
				o.color = VFXTransformFinalColor(o.color,i);
			
			#if VFX_FEATURE_MOTION_VECTORS_FORWARD
				
						
						//No w division with fast path of motion vectors
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
						float2 velocity = i.VFX_VARYING_VELOCITY_CPOS - i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS;
						#else
						float2 velocity = (i.VFX_VARYING_VELOCITY_CPOS.xy/i.VFX_VARYING_VELOCITY_CPOS.w) - (i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.xy/i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.w);
						#endif
						
						#if UNITY_UV_STARTS_AT_TOP
							velocity.y = -velocity.y;
						#endif
						float4 encodedMotionVector = 0.0f;
						VFXEncodeMotionVector(velocity * 0.5f, encodedMotionVector);
						
				o.outMotionVector = encodedMotionVector;
				o.outMotionVector.a = o.color.a < i.VFX_VARYING_ALPHATHRESHOLD ? 0.0f : 1.0f; //Independant clipping for motion vector pass
			#endif
			
			    
			    		#if defined(DEBUG_DISPLAY)
			    		    InputData inputData;
			    		    SurfaceData surfaceData;
			    		    ZERO_INITIALIZE(SurfaceData, surfaceData);
			    		    ZERO_INITIALIZE(InputData, inputData);
			    		    surfaceData.albedo = o.color.rgb;
			    		    surfaceData.alpha = o.color.a;
			    		
			    		    half4 debugColor;
			    		    if (CanDebugOverrideOutputColor(inputData, surfaceData, debugColor))
			    		    {
			    		        o.color = debugColor;
			    		    }
			    		#endif
			    		
			
				return o;
			}
			
		
			ENDHLSL
		}
		

		
		// Forward pass
		Pass
		{		
			Tags { "LightMode"="Universal2D" }
			
			HLSLPROGRAM
			#pragma target 4.5
			struct ps_input
			{
				float4 pos : SV_POSITION;
				#if USE_FLIPBOOK_INTERPOLATION
				float4 uv : TEXCOORD0;
				#else
					#if USE_FLIPBOOK_ARRAY_LAYOUT
					float3 uv : TEXCOORD0;
					#else
					float2 uv : TEXCOORD0;
					#endif
				#endif
				#if VFX_SHADERGRAPH_HAS_UV1
				float4 uv1 : TEXCOORD1;
				#endif
				#if VFX_SHADERGRAPH_HAS_UV2
				float4 uv2 : TEXCOORD2;
				#endif
				#if VFX_SHADERGRAPH_HAS_UV3
				float4 uv3 : TEXCOORD3;
				#endif
				#if VFX_SHADERGRAPH_HAS_COLOR
				float4 vertexColor : COLOR1;
				#endif
				#if VFX_NEEDS_COLOR_INTERPOLATOR
				nointerpolation float4 color : COLOR0;
				#endif
				#if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_FLIPBOOK_INTERPOLATION || USE_EXPOSURE_WEIGHT || VFX_FEATURE_MOTION_VECTORS_FORWARD
				// x: inverse soft particles fade distance
				// y: alpha threshold
				// z: frame blending factor
				// w: exposure weight
				nointerpolation float4 builtInInterpolants : TEXCOORD4;
				#endif
				#if USE_FLIPBOOK_MOTIONVECTORS
				// x: motion vectors scale X
				// y: motion vectors scale Y
				nointerpolation float2 builtInInterpolants2 : TEXCOORD5;
				#endif
				#if VFX_NEEDS_POSWS_INTERPOLATOR
				float3 posWS : TEXCOORD6;
				#endif
			
				#if VFX_FEATURE_MOTION_VECTORS_FORWARD
				VFX_DECLARE_MOTION_VECTORS_STORAGE(7,8)
				#endif
			
				#if SHADERGRAPH_NEEDS_NORMAL_FORWARD || FORCE_NORMAL_OUTPUT_UNLIT_VERTEX_SHADER
				float3 normal : TEXCOORD9;
				#endif
				#if SHADERGRAPH_NEEDS_TANGENT_FORWARD
				float4 tangent : TEXCOORD10;
				#endif
			
				
			
				UNITY_VERTEX_OUTPUT_STEREO
			
			    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
			};
			
			struct ps_output
			{
				float4 color : SV_Target0;
			#if VFX_FEATURE_MOTION_VECTORS_FORWARD
				float4 outMotionVector : SV_Target1;
			#endif
			};
			
			#define VFX_VARYING_PS_INPUTS ps_input
			#define VFX_VARYING_POSCS pos
			#define VFX_VARYING_COLOR color.rgb
			#define VFX_VARYING_ALPHA color.a
			#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
			#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
			#define VFX_VARYING_FRAMEBLEND builtInInterpolants.z
			#define VFX_VARYING_MOTIONVECTORSCALE builtInInterpolants2.xy
			#define VFX_VARYING_UV uv
			#if VFX_NEEDS_POSWS_INTERPOLATOR
			#define VFX_VARYING_POSWS posWS
			#endif
			#if USE_EXPOSURE_WEIGHT
			#define VFX_VARYING_EXPOSUREWEIGHT builtInInterpolants.w
			#endif
			#if VFX_FEATURE_MOTION_VECTORS_FORWARD
			#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
			#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
			#endif
			
			
			
			#if SHADERGRAPH_NEEDS_NORMAL_FORWARD || FORCE_NORMAL_OUTPUT_UNLIT_VERTEX_SHADER
			#define VFX_VARYING_NORMAL normal
			#endif
			#if SHADERGRAPH_NEEDS_TANGENT_FORWARD
			#define VFX_VARYING_TANGENT tangent
			#endif
			
			#if !(defined(VFX_VARYING_PS_INPUTS) && defined(VFX_VARYING_POSCS))
			#error VFX_VARYING_PS_INPUTS, VFX_VARYING_POSCS and VFX_VARYING_UV must be defined.
			#endif
			
			#include "Packages/com.unity.render-pipelines.universal/Runtime/VFXGraph/Shaders/VFXCommon.hlsl"
			#include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.hlsl"
			#include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommonOutput.hlsl"
			

			void SetAttribute_3278B22F(inout float size, float _Size) /*channels:XYZ */
			{
			    size = _Size;
			}
			

			
			struct vs_input
			{
				float3 pos : POSITION;
				float2 uv : TEXCOORD0;
			    #if VFX_SHADERGRAPH_HAS_UV1
			    float4 uv1 : TEXCOORD1;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV2
			    float4 uv2 : TEXCOORD2;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV3
			    float4 uv3 : TEXCOORD3;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_COLOR
			    float4 vertexColor : COLOR;
			    #endif
				float3 normal : NORMAL;
				#if defined(VFX_VARYING_TANGENT) || SHADERGRAPH_HAS_NORMAL
				float4 tangent : TANGENT;
				#endif
				VFX_DECLARE_INSTANCE_ID
			};
			
			#pragma vertex vert
			VFX_VARYING_PS_INPUTS vert(vs_input i)
			{
			    VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;
			
				UNITY_SETUP_INSTANCE_ID(i);
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
			
				uint index = VFX_GET_INSTANCE_ID(i);
			
				
						uint instanceIndex, instanceActiveIndex, instanceCurrentIndex;
						index = VFXInitInstancing(index, instanceIndex, instanceActiveIndex, instanceCurrentIndex);
						
				
			
				struct ContextData
				{
				    uint maxParticleCount;
				    uint systemSeed;
				    uint initSpawnIndex;
				};
				ContextData contextData;
				uint4 rawContextData = graphValuesBuffer.Load4(instanceActiveIndex * 160);
				contextData.maxParticleCount = rawContextData.x;
				contextData.systemSeed = rawContextData.y;
				contextData.initSpawnIndex = rawContextData.z;
				

				uint systemSeed = contextData.systemSeed;
				uint nbMax = contextData.maxParticleCount;
			
				
						#if HAS_STRIPS && !VFX_HAS_INDIRECT_DRAW
							// We render one particle less for each strip in this case
							nbMax -= STRIP_COUNT;
						#endif
						
						uint deadCount = 0;
						#if USE_DEAD_LIST_COUNT
						deadCount = deadList[instanceIndex];
						#endif
						#if VFX_USE_INSTANCING
						if (index >= nbMax - deadCount)
						#else
						if (index >= asuint(nbMax) - deadCount)
						#endif
						{
							CULL_VERTEX(o);
						}
						
						VFXAttributes attributes = (VFXAttributes)0;
						VFXSourceAttributes sourceAttributes = (VFXSourceAttributes)0;
						
						#if VFX_HAS_INDIRECT_DRAW
						if (index >= indirectBuffer[instanceActiveIndex])
						{
							CULL_VERTEX(o);
						}
						index = indirectBuffer[VFXGetIndirectBufferIndex(index, instanceActiveIndex)];
						#endif
						
						#if HAS_STRIPS_DATA
						StripData stripData;
						uint relativeIndexInStrip = 0;
						if (!FindIndexInStrip(index, id, instanceIndex, relativeIndexInStrip, stripData))
						{
							CULL_VERTEX(o);
						}
						#endif
						
						#if VFX_HAS_INDIRECT_DRAW
						attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x140) + (index * 0x4 + 0x20)) << 2));
						attributes.angleX = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA0)) << 2));
						attributes.angleY = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA1)) << 2));
						attributes.angleZ = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA2)) << 2));
						attributes.color = float3(1, 1, 1);
						attributes.alpha = (float)1;
						attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x1 + 0x100)) << 2));
						attributes.axisX = float3(1, 0, 0);
						attributes.axisY = float3(0, 1, 0);
						attributes.axisZ = float3(0, 0, 1);
						attributes.pivotX = (float)0;
						attributes.pivotY = (float)0;
						attributes.pivotZ = (float)0;
						attributes.size = (float)0.100000001;
						attributes.scaleX = (float)1;
						attributes.scaleY = (float)1;
						attributes.scaleZ = (float)1;
						
				
						#else
						attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x1 + 0x100)) << 2));
						
				
						#if !HAS_STRIPS
						if (!attributes.alive)
						{
							CULL_VERTEX(o);
						}
						#endif
						
						attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x140) + (index * 0x4 + 0x20)) << 2));
						attributes.angleX = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA0)) << 2));
						attributes.angleY = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA1)) << 2));
						attributes.angleZ = asfloat(attributeBuffer.Load(((instanceIndex * 0x140) + (index * 0x3 + 0xA2)) << 2));
						attributes.color = float3(1, 1, 1);
						attributes.alpha = (float)1;
						attributes.axisX = float3(1, 0, 0);
						attributes.axisY = float3(0, 1, 0);
						attributes.axisZ = float3(0, 0, 1);
						attributes.pivotX = (float)0;
						attributes.pivotY = (float)0;
						attributes.pivotZ = (float)0;
						attributes.size = (float)0.100000001;
						attributes.scaleX = (float)1;
						attributes.scaleY = (float)1;
						attributes.scaleZ = (float)1;
						
				
						#endif
						
						// Initialize built-in needed attributes
						#if HAS_STRIPS_DATA
						InitStripAttributes(index, attributes, stripData);
						#endif
						
				{
				    SetAttribute_3278B22F( /*inout */attributes.size, (float)0.100000001);
				}
				

			
				if (!attributes.alive)
					return o;
			
			    #ifdef VFX_VARYING_UV
			    o.VFX_VARYING_UV.xy = i.uv;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV1
			    o.uv1 = i.uv1;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV2
			    o.uv2 = i.uv2;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_UV3
			    o.uv3 = i.uv3;
			    #endif
			    #if VFX_SHADERGRAPH_HAS_COLOR
			    o.vertexColor = i.vertexColor;
			    #endif
			
				
						float3 size3 = float3(attributes.size,attributes.size,attributes.size);
						#if VFX_USE_SCALEX_CURRENT
						size3.x *= attributes.scaleX;
						#endif
						#if VFX_USE_SCALEY_CURRENT
						size3.y *= attributes.scaleY;
						#endif
						#if VFX_USE_SCALEZ_CURRENT
						size3.z *= attributes.scaleZ;
						#endif
						
			
				float3 inputVertexPosition = i.pos;
				float4x4 elementToVFX = GetElementToVFXMatrix(
					attributes.axisX,
					attributes.axisY,
					attributes.axisZ,
					float3(attributes.angleX,attributes.angleY,attributes.angleZ),
					float3(attributes.pivotX,attributes.pivotY,attributes.pivotZ),
					size3,
					attributes.position);
			
				float3 vPos = mul(elementToVFX,float4(inputVertexPosition,1.0f)).xyz;
				float4 csPos = TransformPositionVFXToClip(vPos);
				o.VFX_VARYING_POSCS = csPos;
			
				// TODO This is needed only if in local space (to handle non uniform scale) or if scale attributes are stored/written (no way to know atm)
				float3x3 elementToVFX_N = GetElementToVFXMatrixNormal(
					attributes.axisX,
					attributes.axisY,
					attributes.axisZ,
					float3(attributes.angleX,attributes.angleY,attributes.angleZ),
					size3);
			
				float3 normalWS = normalize(TransformNormalVFXToWorld(mul(elementToVFX_N, i.normal)));
				#ifdef VFX_VARYING_NORMAL
				float normalFlip = (size3.x * size3.y * size3.z) < 0 ? -1 : 1;
				o.VFX_VARYING_NORMAL = normalFlip * normalWS;
				#endif
				#ifdef VFX_VARYING_TANGENT
				o.VFX_VARYING_TANGENT = float4(normalize(TransformDirectionVFXToWorld(mul((float3x3)elementToVFX,i.tangent.xyz))),i.tangent.w);
				#endif
			
				
						#if VFX_FEATURE_MOTION_VECTORS && defined(VFX_VARYING_VELOCITY_CPOS_PREVIOUS) && defined(VFX_VARYING_VELOCITY_CPOS)
						
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = (float2)0.0f;
						#else
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = float4(0.0f, 0.0f, 0.0f, 1.0f);
						#endif
						
						
						uint elementToVFXBaseIndex;
						if (TryGetElementToVFXBaseIndex(index, instanceIndex, elementToVFXBaseIndex, currentFrameIndex))
						{
						float4 cPos = TransformPositionVFXToNonJitteredClip(vPos);
						
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = VFXGetPreviousClipPosition(elementToVFXBaseIndex, id).xy;
							o.VFX_VARYING_VELOCITY_CPOS = cPos.xy / cPos.w;
						#else
							float4x4 previousElementToVFX = VFXGetPreviousElementToVFX(elementToVFXBaseIndex);
							float3 oldvPos = mul(previousElementToVFX, float4(inputVertexPosition, 1.0f)).xyz;
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = TransformPositionVFXToPreviousClip(oldvPos);
							o.VFX_VARYING_VELOCITY_CPOS = cPos;
						#endif
						
						}
						#endif
						
			
				
						#if VFX_USE_COLOR_CURRENT && defined(VFX_VARYING_COLOR)
						o.VFX_VARYING_COLOR = attributes.color;
						#endif
						#if VFX_USE_ALPHA_CURRENT && defined(VFX_VARYING_ALPHA)
						o.VFX_VARYING_ALPHA = attributes.alpha;
						#endif
						
						#ifdef VFX_VARYING_EXPOSUREWEIGHT
						
						o.VFX_VARYING_EXPOSUREWEIGHT = exposureWeight;
						#endif
						
						#if USE_SOFT_PARTICLE && defined(VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE)
						
						o.VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE = invSoftParticlesFadeDistance;
						#endif
						
						#if (USE_ALPHA_TEST || VFX_FEATURE_MOTION_VECTORS_FORWARD) && (!VFX_SHADERGRAPH || !HAS_SHADERGRAPH_PARAM_ALPHACLIPTHRESHOLD) && defined(VFX_VARYING_ALPHATHRESHOLD)
						
						o.VFX_VARYING_ALPHATHRESHOLD = alphaThreshold;
						#endif
						
						#if USE_UV_SCALE_BIAS
						
						
						#if defined (VFX_VARYING_UV)
						o.VFX_VARYING_UV.xy = o.VFX_VARYING_UV.xy * uvScale + uvBias;
						#endif
						#endif
						
						#ifdef VFX_VARYING_ANGLEFADE
						
						o.VFX_VARYING_ANGLEFADE = angleFade;
						#endif
						
						#ifdef VFX_VARYING_FADEFACTOR
						
						o.VFX_VARYING_FADEFACTOR = fadeFactor;
						#endif
						
						#ifdef VFX_VARYING_DECALLAYER
						
						o.VFX_VARYING_DECALLAYER = decalLayerMask;
						#endif
						
						#if defined(VFX_VARYING_POSWS)
						o.VFX_VARYING_POSWS = TransformPositionVFXToWorld(vPos);
						#endif
						
						#if VFX_USE_INSTANCING
						    #ifdef UNITY_INSTANCING_ENABLED
						    o.VFX_VARYINGS_INSTANCE_CURRENT_INDEX = unity_InstanceID;
						    #endif
						o.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX = instanceActiveIndex;
						#endif
						
			
				
						#if USE_FLIPBOOK && defined(VFX_VARYING_UV)
							#if USE_FLIPBOOK_ARRAY_LAYOUT
								
								#if USE_FLIPBOOK_INTERPOLATION
									VFXUVData uvData = GetUVData(flipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex, attributes.texIndexBlend);
								#else
									VFXUVData uvData = GetUVData(flipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex);
								#endif
								o.VFX_VARYING_UV.xyz = uvData.uvs.xyz;
								#if USE_FLIPBOOK_INTERPOLATION && defined(VFX_VARYING_UV) && defined (VFX_VARYING_FRAMEBLEND)
									o.VFX_VARYING_UV.w = uvData.uvs.w;
									o.VFX_VARYING_FRAMEBLEND = uvData.blend;
									#if USE_FLIPBOOK_MOTIONVECTORS && defined(VFX_VARYING_MOTIONVECTORSCALE)
										
										o.VFX_VARYING_MOTIONVECTORSCALE = motionVectorScale;
									#endif
								#endif
							#else
								
								
								#if USE_FLIPBOOK_INTERPOLATION
									VFXUVData uvData = GetUVData(flipBookSize, invFlipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex, attributes.texIndexBlend);
								#else
									VFXUVData uvData = GetUVData(flipBookSize, invFlipBookSize, o.VFX_VARYING_UV.xy, attributes.texIndex);
								#endif
								o.VFX_VARYING_UV.xy = uvData.uvs.xy;
								#if USE_FLIPBOOK_INTERPOLATION && defined(VFX_VARYING_UV) && defined (VFX_VARYING_FRAMEBLEND)
									o.VFX_VARYING_UV.zw = uvData.uvs.zw;
									o.VFX_VARYING_FRAMEBLEND = uvData.blend;
									#if USE_FLIPBOOK_MOTIONVECTORS && defined(VFX_VARYING_MOTIONVECTORSCALE)
										
										o.VFX_VARYING_MOTIONVECTORSCALE = motionVectorScale * invFlipBookSize;
									#endif
								#endif
							#endif
						#endif
						
			
				
			
			    
			
				return o;
			}
			
			
			
			
			
			
			
			
			
			#pragma fragment frag
			ps_output frag(ps_input i)
			{
				UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
				ps_output o = (ps_output)0;
				VFXTransformPSInputs(i);
			
			#if VFX_USE_GRAPH_VALUES
			    uint instanceActiveIndex = i.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX;
			    
			#endif
			
				
							#ifdef VFX_VARYING_NORMAL
							#if USE_DOUBLE_SIDED
							const float faceMul = frontFace ? 1.0f : -1.0f;
							#else
							const float faceMul = 1.0f;
							#endif
							
							float3 normalWS = normalize(i.VFX_VARYING_NORMAL * faceMul);
							const VFXUVData uvData = GetUVData(i);
							
							#ifdef VFX_VARYING_TANGENT
							float3 tangentWS = normalize(i.VFX_VARYING_TANGENT.xyz);
							float3 bitangentWS = cross(normalWS,tangentWS) * (i.VFX_VARYING_TANGENT.w * faceMul);
							float3x3 tbn = float3x3(tangentWS,bitangentWS,normalWS);
							
							#if USE_NORMAL_MAP
							float3 n = SampleNormalMap(VFX_SAMPLER(normalMap),uvData);
							float normalScale = 1.0f;
							#ifdef VFX_VARYING_NORMALSCALE
							normalScale = i.VFX_VARYING_NORMALSCALE;
							#endif
							normalWS = normalize(lerp(normalWS,mul(n,tbn),normalScale));
							#endif
							#endif
							#endif
							
			
				#if VFX_SHADERGRAPH
					
					
			
					#if HAS_SHADERGRAPH_PARAM_BASECOLOR
						o.color.rgb = OUTSG..rgb;
						o.color = VFXApplyPreExposure(o.color, i);
					#endif
			
					#if HAS_SHADERGRAPH_PARAM_EMISSION
						float4 emission = float4(OUTSG..rgb, 0.0f);
						emission = VFXApplyPreExposure(emission, 1.0f);
						o.color.rgb += emission.rgb;
					#endif
			
					#if HAS_SHADERGRAPH_PARAM_ALPHA
						o.color.a = OUTSG.;
					#endif
				#else
					#define VFX_TEXTURE_COLOR VFXGetTextureColor(VFX_SAMPLER(mainTexture),i)
					
							
							float4 color = VFXGetFragmentColor(i);
							
							#ifndef VFX_TEXTURE_COLOR
								#define VFX_TEXTURE_COLOR float4(1.0,1.0,1.0,1.0)
							#endif
							
							#if VFX_COLORMAPPING_DEFAULT
								o.color = color * VFX_TEXTURE_COLOR;
							#endif
							
							#if VFX_COLORMAPPING_GRADIENTMAPPED
								
								o.color = SampleGradient(gradient, VFX_TEXTURE_COLOR.a * color.a) * float4(color.rgb,1.0);
							#endif
							
							
					o.color = VFXApplyPreExposure(o.color, i);
				#endif
			
				o.color = VFXApplyAO(o.color,i);
				o.color = VFXApplyFog(o.color,i);
				VFXClipFragmentColor(o.color.a,i);
				o.color.a = saturate(o.color.a);
				o.color = VFXTransformFinalColor(o.color,i);
			
			#if VFX_FEATURE_MOTION_VECTORS_FORWARD
				
						
						//No w division with fast path of motion vectors
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
						float2 velocity = i.VFX_VARYING_VELOCITY_CPOS - i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS;
						#else
						float2 velocity = (i.VFX_VARYING_VELOCITY_CPOS.xy/i.VFX_VARYING_VELOCITY_CPOS.w) - (i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.xy/i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.w);
						#endif
						
						#if UNITY_UV_STARTS_AT_TOP
							velocity.y = -velocity.y;
						#endif
						float4 encodedMotionVector = 0.0f;
						VFXEncodeMotionVector(velocity * 0.5f, encodedMotionVector);
						
				o.outMotionVector = encodedMotionVector;
				o.outMotionVector.a = o.color.a < i.VFX_VARYING_ALPHATHRESHOLD ? 0.0f : 1.0f; //Independant clipping for motion vector pass
			#endif
			
			    
			    		#if defined(DEBUG_DISPLAY)
			    		    InputData inputData;
			    		    SurfaceData surfaceData;
			    		    ZERO_INITIALIZE(SurfaceData, surfaceData);
			    		    ZERO_INITIALIZE(InputData, inputData);
			    		    surfaceData.albedo = o.color.rgb;
			    		    surfaceData.alpha = o.color.a;
			    		
			    		    half4 debugColor;
			    		    if (CanDebugOverrideOutputColor(inputData, surfaceData, debugColor))
			    		    {
			    		        o.color = debugColor;
			    		    }
			    		#endif
			    		
			
				return o;
			}
			
		
			ENDHLSL
		}
		

	}
}
